//! Report-related events for generating accident reconstruction reports.

use crate::event::Event;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Report generated event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportGenerated {
    /// Report identifier.
    pub report_id: String,

    /// Associated case identifier.
    pub case_id: String,

    /// Report type.
    pub report_type: ReportType,

    /// Report title.
    pub title: String,

    /// Report format.
    pub format: ReportFormat,

    /// Sections included in the report.
    pub sections: Vec<String>,

    /// Generated by.
    pub generated_by: String,

    /// Timestamp when generated.
    pub generated_at: DateTime<Utc>,

    /// Generation parameters.
    pub parameters: HashMap<String, String>,
}

impl Event for ReportGenerated {
    fn event_type(&self) -> &'static str {
        "ReportGenerated"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report section added event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportSectionAdded {
    /// Report identifier.
    pub report_id: String,

    /// Section identifier.
    pub section_id: String,

    /// Section type.
    pub section_type: SectionType,

    /// Section title.
    pub title: String,

    /// Section content.
    pub content: String,

    /// Section order/position.
    pub order: u32,

    /// Added by.
    pub added_by: String,

    /// Timestamp when added.
    pub added_at: DateTime<Utc>,
}

impl Event for ReportSectionAdded {
    fn event_type(&self) -> &'static str {
        "ReportSectionAdded"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report section updated event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportSectionUpdated {
    /// Report identifier.
    pub report_id: String,

    /// Section identifier.
    pub section_id: String,

    /// Updated title.
    pub title: Option<String>,

    /// Updated content.
    pub content: Option<String>,

    /// Updated order.
    pub order: Option<u32>,

    /// Updated by.
    pub updated_by: String,

    /// Timestamp when updated.
    pub updated_at: DateTime<Utc>,
}

impl Event for ReportSectionUpdated {
    fn event_type(&self) -> &'static str {
        "ReportSectionUpdated"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report image added event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportImageAdded {
    /// Report identifier.
    pub report_id: String,

    /// Image identifier.
    pub image_id: String,

    /// Section identifier this image belongs to.
    pub section_id: Option<String>,

    /// Image caption.
    pub caption: Option<String>,

    /// Image file reference.
    pub file_reference: String,

    /// Image type.
    pub image_type: ImageType,

    /// Width in pixels.
    pub width: Option<u32>,

    /// Height in pixels.
    pub height: Option<u32>,

    /// Added by.
    pub added_by: String,

    /// Timestamp when added.
    pub added_at: DateTime<Utc>,
}

impl Event for ReportImageAdded {
    fn event_type(&self) -> &'static str {
        "ReportImageAdded"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report exported event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportExported {
    /// Report identifier.
    pub report_id: String,

    /// Export format.
    pub export_format: ExportFormat,

    /// File path or location.
    pub file_path: String,

    /// File size in bytes.
    pub file_size: u64,

    /// Export quality/settings.
    pub settings: HashMap<String, String>,

    /// Exported by.
    pub exported_by: String,

    /// Timestamp when exported.
    pub exported_at: DateTime<Utc>,
}

impl Event for ReportExported {
    fn event_type(&self) -> &'static str {
        "ReportExported"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report shared event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportShared {
    /// Report identifier.
    pub report_id: String,

    /// Recipients.
    pub recipients: Vec<String>,

    /// Share method.
    pub share_method: ShareMethod,

    /// Share link or reference.
    pub share_link: Option<String>,

    /// Expiration date for the share.
    pub expires_at: Option<DateTime<Utc>>,

    /// Access level.
    pub access_level: AccessLevel,

    /// Shared by.
    pub shared_by: String,

    /// Timestamp when shared.
    pub shared_at: DateTime<Utc>,

    /// Message or notes.
    pub message: Option<String>,
}

impl Event for ReportShared {
    fn event_type(&self) -> &'static str {
        "ReportShared"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report approved event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportApproved {
    /// Report identifier.
    pub report_id: String,

    /// Approved by.
    pub approved_by: String,

    /// Approval level.
    pub approval_level: ApprovalLevel,

    /// Timestamp when approved.
    pub approved_at: DateTime<Utc>,

    /// Approval notes or comments.
    pub notes: Option<String>,

    /// Digital signature.
    pub signature: Option<String>,
}

impl Event for ReportApproved {
    fn event_type(&self) -> &'static str {
        "ReportApproved"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report rejected event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportRejected {
    /// Report identifier.
    pub report_id: String,

    /// Rejected by.
    pub rejected_by: String,

    /// Timestamp when rejected.
    pub rejected_at: DateTime<Utc>,

    /// Rejection reason.
    pub reason: String,

    /// Required changes.
    pub required_changes: Vec<String>,
}

impl Event for ReportRejected {
    fn event_type(&self) -> &'static str {
        "ReportRejected"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report version created event.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReportVersionCreated {
    /// Report identifier.
    pub report_id: String,

    /// Version number.
    pub version: u32,

    /// Version description.
    pub description: Option<String>,

    /// Changes from previous version.
    pub changes: Vec<String>,

    /// Created by.
    pub created_by: String,

    /// Timestamp when created.
    pub created_at: DateTime<Utc>,
}

impl Event for ReportVersionCreated {
    fn event_type(&self) -> &'static str {
        "ReportVersionCreated"
    }

    fn aggregate_id(&self) -> &str {
        &self.report_id
    }

    fn aggregate_type(&self) -> &'static str {
        "Report"
    }
}

/// Report type enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ReportType {
    /// Full accident reconstruction report.
    FullReconstruction,

    /// Executive summary.
    ExecutiveSummary,

    /// Technical analysis.
    TechnicalAnalysis,

    /// Scene documentation.
    SceneDocumentation,

    /// Simulation results.
    SimulationResults,

    /// Expert opinion.
    ExpertOpinion,

    /// Custom report type.
    Custom,
}

/// Report format enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ReportFormat {
    /// HTML format.
    Html,

    /// Markdown format.
    Markdown,

    /// Plain text.
    PlainText,

    /// Rich text.
    RichText,
}

/// Section type enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum SectionType {
    /// Introduction.
    Introduction,

    /// Executive summary.
    Summary,

    /// Methodology.
    Methodology,

    /// Scene description.
    SceneDescription,

    /// Vehicle analysis.
    VehicleAnalysis,

    /// Simulation results.
    SimulationResults,

    /// Conclusions.
    Conclusions,

    /// Recommendations.
    Recommendations,

    /// Appendix.
    Appendix,

    /// Custom section.
    Custom,
}

/// Image type enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ImageType {
    /// Photo.
    Photo,

    /// Screenshot.
    Screenshot,

    /// 3D rendering.
    Rendering3D,

    /// Diagram.
    Diagram,

    /// Chart or graph.
    Chart,

    /// Map.
    Map,
}

/// Export format enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ExportFormat {
    /// PDF document.
    Pdf,

    /// Microsoft Word.
    Docx,

    /// HTML.
    Html,

    /// Markdown.
    Markdown,

    /// LaTeX.
    Latex,

    /// JSON data.
    Json,
}

/// Share method enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ShareMethod {
    /// Email.
    Email,

    /// Link sharing.
    Link,

    /// Direct download.
    Download,

    /// Cloud storage.
    Cloud,
}

/// Access level enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum AccessLevel {
    /// View only.
    ViewOnly,

    /// Can comment.
    Comment,

    /// Can edit.
    Edit,

    /// Full control.
    Admin,
}

/// Approval level enumeration.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ApprovalLevel {
    /// Peer review approval.
    PeerReview,

    /// Supervisor approval.
    Supervisor,

    /// Expert approval.
    Expert,

    /// Legal approval.
    Legal,

    /// Final approval.
    Final,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_report_generated_event() {
        let event = ReportGenerated {
            report_id: "report-123".to_string(),
            case_id: "case-456".to_string(),
            report_type: ReportType::FullReconstruction,
            title: "Accident Reconstruction Report".to_string(),
            format: ReportFormat::Html,
            sections: vec!["intro".to_string(), "analysis".to_string()],
            generated_by: "user-789".to_string(),
            generated_at: Utc::now(),
            parameters: HashMap::new(),
        };

        assert_eq!(event.event_type(), "ReportGenerated");
        assert_eq!(event.aggregate_id(), "report-123");
    }

    #[test]
    fn test_report_exported_event() {
        let event = ReportExported {
            report_id: "report-123".to_string(),
            export_format: ExportFormat::Pdf,
            file_path: "/exports/report.pdf".to_string(),
            file_size: 1024000,
            settings: HashMap::new(),
            exported_by: "user-789".to_string(),
            exported_at: Utc::now(),
        };

        assert_eq!(event.event_type(), "ReportExported");
    }
}
