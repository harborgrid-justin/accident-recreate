//! Tire friction model using Pacejka Magic Formula.

use nalgebra::Vector3;
use serde::{Deserialize, Serialize};

/// Tire state during simulation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TireState {
    /// Slip angle (rad)
    pub slip_angle: f64,
    /// Slip ratio (longitudinal slip)
    pub slip_ratio: f64,
    /// Normal force on tire (N)
    pub normal_force: f64,
    /// Angular velocity of wheel (rad/s)
    pub angular_velocity: f64,
    /// Is the tire locked (sliding)?
    pub is_locked: bool,
}

impl Default for TireState {
    fn default() -> Self {
        Self {
            slip_angle: 0.0,
            slip_ratio: 0.0,
            normal_force: 0.0,
            angular_velocity: 0.0,
            is_locked: false,
        }
    }
}

/// Forces generated by a tire.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TireForces {
    /// Longitudinal force (N)
    pub longitudinal: f64,
    /// Lateral force (N)
    pub lateral: f64,
    /// Combined force vector
    pub force: Vector3<f64>,
}

/// Pacejka Magic Formula tire model.
///
/// The Magic Formula is the industry standard for tire modeling.
/// Formula: y(x) = D * sin(C * arctan(B*x - E*(B*x - arctan(B*x))))
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TireModel {
    /// Stiffness factor B
    pub stiffness_factor: f64,
    /// Shape factor C
    pub shape_factor: f64,
    /// Peak value D
    pub peak_value: f64,
    /// Curvature factor E
    pub curvature_factor: f64,
    /// Tire radius (m)
    pub radius: f64,
    /// Tire width (m)
    pub width: f64,
    /// Maximum friction coefficient
    pub max_friction: f64,
}

impl TireModel {
    /// Creates a new tire model with default parameters for a passenger car.
    pub fn new() -> Self {
        Self {
            stiffness_factor: 10.0,
            shape_factor: 1.3,
            peak_value: 1.0,
            curvature_factor: 0.97,
            radius: 0.3,  // 30 cm radius
            width: 0.205, // 205 mm width
            max_friction: 1.0,
        }
    }

    /// Creates a performance tire model.
    pub fn performance() -> Self {
        Self {
            stiffness_factor: 12.0,
            shape_factor: 1.4,
            peak_value: 1.1,
            curvature_factor: 0.95,
            radius: 0.32,
            width: 0.245,
            max_friction: 1.1,
        }
    }

    /// Creates a winter tire model.
    pub fn winter() -> Self {
        Self {
            stiffness_factor: 8.0,
            shape_factor: 1.2,
            peak_value: 0.9,
            curvature_factor: 0.98,
            radius: 0.3,
            width: 0.205,
            max_friction: 0.9,
        }
    }

    /// Computes tire forces using the Pacejka Magic Formula.
    pub fn compute_forces(&self, state: &TireState, surface_friction: f64) -> TireForces {
        let effective_friction = self.max_friction * surface_friction;

        // Longitudinal force (based on slip ratio)
        let longitudinal = self.magic_formula(
            state.slip_ratio,
            state.normal_force,
            effective_friction,
            self.stiffness_factor,
        );

        // Lateral force (based on slip angle)
        let lateral = self.magic_formula(
            state.slip_angle,
            state.normal_force,
            effective_friction,
            self.stiffness_factor * 0.8, // Lateral stiffness is typically lower
        );

        // Combine forces using friction circle concept
        let combined_magnitude = (longitudinal * longitudinal + lateral * lateral).sqrt();
        let max_force = effective_friction * state.normal_force;

        let (final_long, final_lat) = if combined_magnitude > max_force {
            // Scale down forces to stay within friction circle
            let scale = max_force / combined_magnitude;
            (longitudinal * scale, lateral * scale)
        } else {
            (longitudinal, lateral)
        };

        TireForces {
            longitudinal: final_long,
            lateral: final_lat,
            force: Vector3::new(final_long, final_lat, 0.0),
        }
    }

    /// Pacejka Magic Formula core calculation.
    ///
    /// Formula: y(x) = D * sin(C * arctan(B*x - E*(B*x - arctan(B*x))))
    fn magic_formula(
        &self,
        slip: f64,
        normal_force: f64,
        friction: f64,
        stiffness: f64,
    ) -> f64 {
        let b = stiffness;
        let c = self.shape_factor;
        let d = normal_force * friction * self.peak_value;
        let e = self.curvature_factor;

        let bx = b * slip;
        let s = bx - e * (bx - bx.atan());

        d * (c * s.atan()).sin()
    }

    /// Calculates slip ratio from wheel and vehicle velocities.
    ///
    /// Slip ratio = (V_wheel - V_vehicle) / V_vehicle
    pub fn calculate_slip_ratio(&self, wheel_angular_velocity: f64, vehicle_velocity: f64) -> f64 {
        let wheel_velocity = wheel_angular_velocity * self.radius;

        if vehicle_velocity.abs() < 0.1 {
            // At very low speeds, use simplified model
            if wheel_angular_velocity.abs() > 0.1 {
                return 1.0; // Full slip
            }
            return 0.0;
        }

        (wheel_velocity - vehicle_velocity) / vehicle_velocity.abs()
    }

    /// Calculates slip angle from lateral and longitudinal velocities.
    ///
    /// Slip angle = arctan(V_lateral / V_longitudinal)
    pub fn calculate_slip_angle(&self, lateral_velocity: f64, longitudinal_velocity: f64) -> f64 {
        if longitudinal_velocity.abs() < 0.1 {
            return 0.0;
        }

        (-lateral_velocity / longitudinal_velocity.abs()).atan()
    }

    /// Estimates tire temperature effect on friction.
    pub fn temperature_factor(&self, temperature_celsius: f64) -> f64 {
        // Optimal tire temperature is typically 80-100Â°C
        let optimal_temp = 90.0;
        let temp_diff = (temperature_celsius - optimal_temp).abs();

        // Friction decreases as temperature moves away from optimal
        (1.0 - (temp_diff / 100.0).min(0.3)).max(0.7)
    }

    /// Estimates tire wear effect on friction.
    pub fn wear_factor(&self, wear_percentage: f64) -> f64 {
        // Linear decrease in friction with wear
        (1.0 - wear_percentage * 0.5).max(0.5)
    }
}

impl Default for TireModel {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tire_model_creation() {
        let tire = TireModel::new();
        assert_eq!(tire.radius, 0.3);

        let performance = TireModel::performance();
        assert!(performance.stiffness_factor > tire.stiffness_factor);
    }

    #[test]
    fn test_magic_formula() {
        let tire = TireModel::new();
        let state = TireState {
            slip_angle: 0.1,    // ~5.7 degrees
            slip_ratio: 0.05,   // 5% slip
            normal_force: 5000.0, // 5 kN
            angular_velocity: 0.0,
            is_locked: false,
        };

        let forces = tire.compute_forces(&state, 1.0);

        // Forces should be non-zero and reasonable
        assert!(forces.longitudinal.abs() > 0.0);
        assert!(forces.lateral.abs() > 0.0);
        assert!(forces.longitudinal.abs() < 10000.0); // Sanity check
    }

    #[test]
    fn test_slip_ratio_calculation() {
        let tire = TireModel::new();

        // Wheel spinning faster than vehicle (acceleration)
        let slip = tire.calculate_slip_ratio(100.0, 20.0);
        assert!(slip > 0.0);

        // Wheel spinning slower than vehicle (braking)
        let slip = tire.calculate_slip_ratio(50.0, 20.0);
        assert!(slip < 0.0);
    }

    #[test]
    fn test_slip_angle_calculation() {
        let tire = TireModel::new();

        let slip_angle = tire.calculate_slip_angle(5.0, 20.0);
        assert!(slip_angle < 0.0); // Negative because of formula

        let slip_angle = tire.calculate_slip_angle(-5.0, 20.0);
        assert!(slip_angle > 0.0);
    }

    #[test]
    fn test_temperature_factor() {
        let tire = TireModel::new();

        let optimal = tire.temperature_factor(90.0);
        assert_eq!(optimal, 1.0);

        let cold = tire.temperature_factor(20.0);
        assert!(cold < 1.0);

        let hot = tire.temperature_factor(150.0);
        assert!(hot < 1.0);
    }
}
