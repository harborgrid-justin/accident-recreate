//! Report export functionality

use super::builder::{Report, SectionContent};
use super::ReportFormat;
use crate::error::{AnalyticsError, Result};
use std::io::Write;
use std::path::Path;

/// Trait for exporting reports to different formats
pub trait ReportExporter: Send + Sync {
    fn export(&self, report: &Report, writer: &mut dyn Write) -> Result<()>;
    fn format(&self) -> ReportFormat;
}

/// JSON exporter
pub struct JsonExporter;

impl ReportExporter for JsonExporter {
    fn export(&self, report: &Report, writer: &mut dyn Write) -> Result<()> {
        let json = serde_json::to_string_pretty(report)?;
        writer.write_all(json.as_bytes())?;
        Ok(())
    }

    fn format(&self) -> ReportFormat {
        ReportFormat::Json
    }
}

/// CSV exporter
pub struct CsvExporter;

impl ReportExporter for CsvExporter {
    fn export(&self, report: &Report, writer: &mut dyn Write) -> Result<()> {
        // Write metadata as header
        writeln!(writer, "# {}", report.metadata.title)?;
        writeln!(writer, "# {}", report.metadata.description)?;
        writeln!(writer, "# Generated at: {}", report.metadata.generated_at)?;
        writeln!(writer, "# Generated by: {}", report.metadata.generated_by)?;
        writeln!(writer)?;

        // Export each section
        for section in &report.sections {
            writeln!(writer, "# Section: {}", section.title)?;

            match &section.content {
                SectionContent::Table(table) => {
                    let mut csv_writer = csv::Writer::from_writer(vec![]);

                    csv_writer.write_record(&table.headers)?;

                    for row in &table.rows {
                        csv_writer.write_record(row)?;
                    }

                    let csv_data = csv_writer.into_inner()?;
                    writer.write_all(&csv_data)?;
                }
                SectionContent::Metrics(metrics) => {
                    let mut csv_writer = csv::Writer::from_writer(vec![]);

                    csv_writer.write_record(&["Metric", "Value", "Unit", "Change"])?;

                    for metric in metrics {
                        let change = metric
                            .change
                            .map(|c| format!("{:.2}", c))
                            .unwrap_or_else(|| "N/A".to_string());

                        csv_writer.write_record(&[
                            &metric.name,
                            &metric.value.to_string(),
                            &metric.unit,
                            &change,
                        ])?;
                    }

                    let csv_data = csv_writer.into_inner()?;
                    writer.write_all(&csv_data)?;
                }
                SectionContent::Text(text) => {
                    writeln!(writer, "{}", text)?;
                }
                SectionContent::Chart(chart) => {
                    writeln!(writer, "# Chart: {} ({})", chart.title, chart.chart_type)?;

                    let mut csv_writer = csv::Writer::from_writer(vec![]);

                    let mut headers = vec!["X".to_string()];
                    for series in &chart.series {
                        headers.push(series.name.clone());
                    }
                    csv_writer.write_record(&headers)?;

                    // Find all unique x values
                    let mut x_values: Vec<f64> = chart
                        .series
                        .iter()
                        .flat_map(|s| s.data.iter().map(|(x, _)| *x))
                        .collect();
                    x_values.sort_by(|a, b| a.partial_cmp(b).unwrap());
                    x_values.dedup();

                    for x in x_values {
                        let mut row = vec![x.to_string()];
                        for series in &chart.series {
                            let y = series
                                .data
                                .iter()
                                .find(|(sx, _)| (*sx - x).abs() < 1e-10)
                                .map(|(_, y)| y.to_string())
                                .unwrap_or_else(|| "".to_string());
                            row.push(y);
                        }
                        csv_writer.write_record(&row)?;
                    }

                    let csv_data = csv_writer.into_inner()?;
                    writer.write_all(&csv_data)?;
                }
                SectionContent::KeyValue(kv) => {
                    let mut csv_writer = csv::Writer::from_writer(vec![]);

                    csv_writer.write_record(&["Key", "Value"])?;

                    for (key, value) in kv {
                        csv_writer.write_record(&[key, value])?;
                    }

                    let csv_data = csv_writer.into_inner()?;
                    writer.write_all(&csv_data)?;
                }
            }

            writeln!(writer)?;
        }

        Ok(())
    }

    fn format(&self) -> ReportFormat {
        ReportFormat::Csv
    }
}

/// HTML exporter
pub struct HtmlExporter;

impl ReportExporter for HtmlExporter {
    fn export(&self, report: &Report, writer: &mut dyn Write) -> Result<()> {
        writeln!(writer, "<!DOCTYPE html>")?;
        writeln!(writer, "<html>")?;
        writeln!(writer, "<head>")?;
        writeln!(writer, "<title>{}</title>", report.metadata.title)?;
        writeln!(writer, "<style>")?;
        writeln!(writer, "body {{ font-family: Arial, sans-serif; margin: 20px; }}")?;
        writeln!(writer, "h1 {{ color: #333; }}")?;
        writeln!(writer, "h2 {{ color: #666; border-bottom: 1px solid #ccc; }}")?;
        writeln!(writer, "table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}")?;
        writeln!(writer, "th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}")?;
        writeln!(writer, "th {{ background-color: #f2f2f2; }}")?;
        writeln!(writer, ".metric {{ display: inline-block; margin: 10px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}")?;
        writeln!(writer, ".metric-value {{ font-size: 24px; font-weight: bold; color: #007bff; }}")?;
        writeln!(writer, "</style>")?;
        writeln!(writer, "</head>")?;
        writeln!(writer, "<body>")?;

        writeln!(writer, "<h1>{}</h1>", report.metadata.title)?;
        writeln!(writer, "<p>{}</p>", report.metadata.description)?;
        writeln!(
            writer,
            "<p><em>Generated at: {}</em></p>",
            report.metadata.generated_at
        )?;

        for section in &report.sections {
            writeln!(writer, "<h2>{}</h2>", section.title)?;

            if !section.description.is_empty() {
                writeln!(writer, "<p>{}</p>", section.description)?;
            }

            match &section.content {
                SectionContent::Text(text) => {
                    writeln!(writer, "<p>{}</p>", text)?;
                }
                SectionContent::Table(table) => {
                    writeln!(writer, "<table>")?;
                    writeln!(writer, "<thead><tr>")?;
                    for header in &table.headers {
                        writeln!(writer, "<th>{}</th>", header)?;
                    }
                    writeln!(writer, "</tr></thead>")?;
                    writeln!(writer, "<tbody>")?;
                    for row in &table.rows {
                        writeln!(writer, "<tr>")?;
                        for cell in row {
                            writeln!(writer, "<td>{}</td>", cell)?;
                        }
                        writeln!(writer, "</tr>")?;
                    }
                    writeln!(writer, "</tbody>")?;
                    writeln!(writer, "</table>")?;
                }
                SectionContent::Metrics(metrics) => {
                    writeln!(writer, "<div>")?;
                    for metric in metrics {
                        writeln!(writer, "<div class='metric'>")?;
                        writeln!(writer, "<div>{}</div>", metric.name)?;
                        writeln!(
                            writer,
                            "<div class='metric-value'>{} {}</div>",
                            metric.value, metric.unit
                        )?;
                        if let Some(change) = metric.change {
                            writeln!(writer, "<div>Change: {:.2}%</div>", change)?;
                        }
                        writeln!(writer, "</div>")?;
                    }
                    writeln!(writer, "</div>")?;
                }
                SectionContent::Chart(chart) => {
                    writeln!(
                        writer,
                        "<p><strong>Chart:</strong> {} ({:?})</p>",
                        chart.title, chart.chart_type
                    )?;
                    writeln!(writer, "<p><em>Chart visualization requires client-side rendering</em></p>")?;
                }
                SectionContent::KeyValue(kv) => {
                    writeln!(writer, "<table>")?;
                    for (key, value) in kv {
                        writeln!(writer, "<tr><th>{}</th><td>{}</td></tr>", key, value)?;
                    }
                    writeln!(writer, "</table>")?;
                }
            }
        }

        writeln!(writer, "</body>")?;
        writeln!(writer, "</html>")?;

        Ok(())
    }

    fn format(&self) -> ReportFormat {
        ReportFormat::Html
    }
}

/// Export a report to a file
pub fn export_to_file(report: &Report, path: impl AsRef<Path>, format: ReportFormat) -> Result<()> {
    let file = std::fs::File::create(path)?;
    let mut writer = std::io::BufWriter::new(file);

    let exporter: Box<dyn ReportExporter> = match format {
        ReportFormat::Json => Box::new(JsonExporter),
        ReportFormat::Csv => Box::new(CsvExporter),
        ReportFormat::Html => Box::new(HtmlExporter),
        ReportFormat::Pdf => {
            return Err(AnalyticsError::Export(
                "PDF export not yet implemented".to_string(),
            ))
        }
    };

    exporter.export(report, &mut writer)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::reporting::builder::{ReportBuilder, TableBuilder};

    #[test]
    fn test_json_export() {
        let report = ReportBuilder::new()
            .title("Test Report")
            .text_section("Introduction", "Test content")
            .build();

        let mut output = Vec::new();
        let exporter = JsonExporter;
        exporter.export(&report, &mut output).unwrap();

        assert!(!output.is_empty());
    }

    #[test]
    fn test_csv_export() {
        let table = TableBuilder::new(vec!["A".to_string(), "B".to_string()])
            .row(vec!["1", "2"])
            .build();

        let report = ReportBuilder::new()
            .title("Test Report")
            .table_section("Data", table)
            .build();

        let mut output = Vec::new();
        let exporter = CsvExporter;
        exporter.export(&report, &mut output).unwrap();

        assert!(!output.is_empty());
    }
}
